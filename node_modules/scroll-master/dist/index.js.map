{"version":3,"sources":["webpack://ScrollMaster/webpack/universalModuleDefinition","webpack://ScrollMaster/webpack/bootstrap","webpack://ScrollMaster/./src/index.ts","webpack://ScrollMaster/./src/scroll.ts","webpack://ScrollMaster/external \"lodash/merge\""],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ScrollMaster","selector","options","this","elements","vp","getViewportSize","body","document","querySelector","wrap","wrapWith","marginTop","stickyFor","stickyClass","stickyContainer","updateScrollTopPosition","addEventListener","run","pageLoaded","setInterval","readyState","clearInterval","querySelectorAll","forEach","element","renderElement","sticky","active","customStyles","getAttribute","parseInt","marginBottom","hasAttribute","container","getStickyContainer","rect","getRectangle","tagName","toLowerCase","onload","wrapElement","activate","insertAdjacentHTML","previousSibling","appendChild","top","height","width","indexOf","push","resizeEvent","initResizeEvents","scrollEvent","initScrollEvents","setPosition","resizeListener","onResizeEvents","destroyResizeEvents","removeEventListener","scrollListener","onScrollEvents","destroyScrollEvents","css","position","left","parentElement","display","classList","add","scrollTop","offsetHeight","remove","update","destroy","parentNode","Math","max","offsetWidth","clientWidth","scrollWidth","clientHeight","scrollHeight","offsetTop","offsetLeft","offsetParent","documentElement","innerWidth","innerHeight","pageYOffset","clientTop","array","callback","len","length","properties","style","require"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ScrollMaster\"] = factory();\n\telse\n\t\troot[\"ScrollMaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import ScrollMaster from \"./scroll\";\n\nexport { ScrollMaster };\nexport default ScrollMaster;\n","import merge from \"lodash/merge\";\n\nexport type Options = {\n  wrap?: any;\n  wrapWith?: any;\n  marginTop?: any;\n  marginBottom?: any;\n  stickyFor?: any;\n  stickyClass?: any;\n  stickyContainer?: any;\n};\n\nexport type StickyElement = HTMLElement & { sticky: any };\n\nexport default class ScrollMaster {\n  selector: string;\n  elements: HTMLElement[];\n  vp: { width: number; height: number };\n  body: HTMLBodyElement | null;\n  options: Options;\n  scrollTop?: number;\n\n  /**\n   * Sticky instance constructor\n   * @constructor\n   * @param {string} selector - Selector which we can find elements\n   * @param {string} options - Global options for sticky elements (could be overwritten by data-{option}=\"\" attributes)\n   */\n  constructor(selector: string = \"\", options: Options = {}) {\n    this.selector = selector;\n    this.elements = [];\n\n    // @ts-ignore\n    this.vp = this.getViewportSize();\n    this.body = document.querySelector(\"body\");\n\n    this.options = merge(options, {\n      wrap: false,\n      wrapWith: \"<span></span>\",\n      marginTop: 0,\n\n      stickyFor: 0,\n      stickyClass: \"stuck\",\n      stickyContainer: \"body\",\n    });\n\n    this.updateScrollTopPosition = this.updateScrollTopPosition.bind(this);\n\n    this.updateScrollTopPosition();\n\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"load\", this.updateScrollTopPosition);\n      window.addEventListener(\"scroll\", this.updateScrollTopPosition);\n    }\n\n    this.run();\n  }\n\n  /**\n   * Function that waits for page to be fully loaded and then renders & activates every sticky element found with specified selector\n   * @function\n   */\n  run() {\n    // wait for page to be fully loaded\n    const pageLoaded = setInterval(() => {\n      if (document.readyState === \"complete\") {\n        clearInterval(pageLoaded);\n\n        const elements = document.querySelectorAll(this.selector);\n        this.forEach(elements, (element: any) => this.renderElement(element));\n      }\n    }, 10);\n  }\n\n  /**\n   * Function that assign needed variables for sticky element, that are used in future for calculations and other\n   * @function\n   * @param {node} element - Element to be rendered\n   */\n  renderElement(element: StickyElement) {\n    // create container for variables needed in future\n    element.sticky = {};\n\n    // set default variables\n    element.sticky.active = false;\n\n    element.sticky.customStyles =\n      element.getAttribute(\"data-custom-styles\") ?? false;\n    element.sticky.marginTop =\n      parseInt(element.getAttribute(\"data-margin-top\") ?? \"\") ||\n      this.options.marginTop;\n    element.sticky.marginBottom =\n      parseInt(element.getAttribute(\"data-margin-bottom\") ?? \"\") ||\n      this.options.marginBottom;\n    element.sticky.stickyFor =\n      parseInt(element.getAttribute(\"data-sticky-for\") ?? \"\") ||\n      this.options.stickyFor;\n    element.sticky.stickyClass =\n      element.getAttribute(\"data-sticky-class\") || this.options.stickyClass;\n    element.sticky.wrap = element.hasAttribute(\"data-sticky-wrap\")\n      ? true\n      : this.options.wrap;\n    // @todo attribute for stickyContainer\n    // element.sticky.stickyContainer = element.getAttribute('data-sticky-container') || this.options.stickyContainer;\n    element.sticky.stickyContainer = this.options.stickyContainer;\n\n    element.sticky.container = this.getStickyContainer(element);\n    element.sticky.container.rect = this.getRectangle(element.sticky.container);\n\n    element.sticky.rect = this.getRectangle(element);\n\n    // fix when element is image that has not yet loaded and width, height = 0\n    if (element.tagName.toLowerCase() === \"img\") {\n      element.onload = () => (element.sticky.rect = this.getRectangle(element));\n    }\n\n    if (element.sticky.wrap) {\n      this.wrapElement(element);\n    }\n\n    // activate rendered element\n    this.activate(element);\n  }\n\n  /**\n   * Wraps element into placeholder element\n   * @function\n   * @param {node} element - Element to be wrapped\n   */\n  wrapElement(element: StickyElement) {\n    element.insertAdjacentHTML(\n      \"beforebegin\",\n      element.getAttribute(\"data-sticky-wrapWith\") || this.options.wrapWith\n    );\n    element.previousSibling?.appendChild(element);\n  }\n\n  /**\n   * Function that activates element when specified conditions are met and then initalise events\n   * @function\n   * @param {Element} element - Element to be activated\n   */\n  activate(element: StickyElement) {\n    if (\n      element.sticky.rect.top + element.sticky.rect.height <\n        element.sticky.container.rect.top +\n          element.sticky.container.rect.height &&\n      element.sticky.stickyFor < this.vp.width &&\n      !element.sticky.active\n    ) {\n      element.sticky.active = true;\n    }\n\n    if (this.elements.indexOf(element) < 0) {\n      this.elements.push(element);\n    }\n\n    if (!element.sticky.resizeEvent) {\n      this.initResizeEvents(element);\n      element.sticky.resizeEvent = true;\n    }\n\n    if (!element.sticky.scrollEvent) {\n      this.initScrollEvents(element);\n      element.sticky.scrollEvent = true;\n    }\n\n    this.setPosition(element);\n  }\n\n  /**\n   * Function which is adding onResizeEvents to window listener and assigns function to element as resizeListener\n   * @function\n   * @param {node} element - Element for which resize events are initialised\n   */\n  initResizeEvents(element: StickyElement) {\n    element.sticky.resizeListener = () => this.onResizeEvents(element);\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"resize\", element.sticky.resizeListener);\n    }\n  }\n\n  /**\n   * Removes element listener from resize event\n   * @function\n   * @param {node} element - Element from which listener is deleted\n   */\n  destroyResizeEvents(element: StickyElement) {\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"resize\", element.sticky.resizeListener);\n    }\n  }\n\n  /**\n   * Function which is fired when user resize window. It checks if element should be activated or deactivated and then run setPosition function\n   * @function\n   * @param {node} element - Element for which event function is fired\n   */\n  onResizeEvents(element: StickyElement) {\n    // @ts-ignore\n    this.vp = this.getViewportSize();\n\n    element.sticky.rect = this.getRectangle(element);\n    element.sticky.container.rect = this.getRectangle(element.sticky.container);\n\n    if (\n      element.sticky.rect.top + element.sticky.rect.height <\n        element.sticky.container.rect.top +\n          element.sticky.container.rect.height &&\n      element.sticky.stickyFor < this.vp.width &&\n      !element.sticky.active\n    ) {\n      element.sticky.active = true;\n    } else if (\n      element.sticky.rect.top + element.sticky.rect.height >=\n        element.sticky.container.rect.top +\n          element.sticky.container.rect.height ||\n      (element.sticky.stickyFor >= this.vp.width && element.sticky.active)\n    ) {\n      element.sticky.active = false;\n    }\n\n    this.setPosition(element);\n  }\n\n  /**\n   * Function which is adding onScrollEvents to window listener and assigns function to element as scrollListener\n   * @function\n   * @param {node} element - Element for which scroll events are initialised\n   */\n  initScrollEvents(element: StickyElement) {\n    element.sticky.scrollListener = () => this.onScrollEvents(element);\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"scroll\", element.sticky.scrollListener);\n    }\n  }\n\n  /**\n   * Removes element listener from scroll event\n   * @function\n   * @param {node} element - Element from which listener is deleted\n   */\n  destroyScrollEvents(element: StickyElement) {\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"scroll\", element.sticky.scrollListener);\n    }\n  }\n\n  /**\n   * Function which is fired when user scroll window. If element is active, function is invoking setPosition function\n   * @function\n   * @param {node} element - Element for which event function is fired\n   */\n  onScrollEvents(element: StickyElement) {\n    if (element.sticky && element.sticky.active) {\n      this.setPosition(element);\n    }\n  }\n\n  /**\n   * Main function for the library. Here are some condition calculations and css appending for sticky element when user scroll window\n   * @function\n   * @param {node} element - Element that will be positioned if it's active\n   */\n  setPosition(element: StickyElement) {\n    this.css(element, { position: \"\", width: \"\", top: \"\", left: \"\" });\n    // element.classList.remove(\"stuck\");\n\n    if (!element.sticky.active) {\n      return;\n    }\n\n    if (!element.sticky.rect.width) {\n      element.sticky.rect = this.getRectangle(element);\n    }\n\n    if (element.sticky.wrap) {\n      this.css(element.parentElement, {\n        display: \"block\",\n        width: element.sticky.rect.width + \"px\",\n        height: element.sticky.rect.height + \"px\",\n      });\n    }\n\n    if (\n      element.sticky.rect.top === 0 &&\n      element.sticky.container === this.body\n    ) {\n      if (!element.sticky.customStyles) {\n        this.css(element, {\n          position: \"fixed\",\n          top: element.sticky.rect.top + \"px\",\n          left: element.sticky.rect.left + \"px\",\n          width: element.sticky.rect.width + \"px\",\n        });\n      }\n      if (element.sticky.stickyClass) {\n        element.classList.add(element.sticky.stickyClass);\n      }\n    } else if (\n      this.scrollTop &&\n      this.scrollTop > element.sticky.rect.top - element.sticky.marginTop\n    ) {\n      if (!element.sticky.customStyles) {\n        this.css(element, {\n          position: \"fixed\",\n          width: element.sticky.rect.width + \"px\",\n          left: element.sticky.rect.left + \"px\",\n        });\n      }\n\n      if (\n        this.scrollTop + element.sticky.rect.height + element.sticky.marginTop >\n        element.sticky.container.rect.top +\n          element.sticky.container.offsetHeight -\n          element.sticky.marginBottom\n      ) {\n        if (element.sticky.stickyClass) {\n          element.classList.remove(element.sticky.stickyClass);\n        }\n\n        this.css(element, {\n          top:\n            element.sticky.container.rect.top +\n            element.sticky.container.offsetHeight -\n            (this.scrollTop +\n              element.sticky.rect.height +\n              element.sticky.marginBottom) +\n            \"px\",\n        });\n      } else {\n        if (element.sticky.stickyClass) {\n          element.classList.add(element.sticky.stickyClass);\n        }\n\n        this.css(element, { top: element.sticky.marginTop + \"px\" });\n      }\n    } else {\n      if (element.sticky.stickyClass) {\n        element.classList.remove(element.sticky.stickyClass);\n      }\n\n      this.css(element, { position: \"\", width: \"\", top: \"\", left: \"\" });\n      if (element.sticky.wrap) {\n        this.css(element.parentElement, { display: \"\", width: \"\", height: \"\" });\n      }\n    }\n  }\n\n  /**\n   * Function that updates element sticky rectangle (with sticky container), then activate or deactivate element, then update position if it's active\n   * @function\n   */\n  update() {\n    this.forEach(this.elements, (element: StickyElement) => {\n      element.sticky.rect = this.getRectangle(element);\n      element.sticky.container.rect = this.getRectangle(\n        element.sticky.container\n      );\n\n      this.activate(element);\n      this.setPosition(element);\n    });\n  }\n\n  /**\n   * Destroys sticky element, remove listeners\n   * @function\n   */\n  destroy() {\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"load\", this.updateScrollTopPosition);\n      window.removeEventListener(\"scroll\", this.updateScrollTopPosition);\n    }\n\n    this.forEach(this.elements, (element: StickyElement) => {\n      this.destroyResizeEvents(element);\n      this.destroyScrollEvents(element);\n      delete element.sticky;\n    });\n  }\n\n  /**\n   * Function that returns container element in which sticky element is stuck (if is not specified, then it's stuck to body)\n   * @function\n   * @param {node} element - Element which sticky container are looked for\n   * @return {node} element - Sticky container\n   */\n  getStickyContainer(element: StickyElement) {\n    let container = element.parentElement;\n\n    while (\n      !container?.hasAttribute(\"data-sticky-container\") &&\n      !container?.parentElement?.querySelector(\n        element.sticky.stickyContainer\n      ) &&\n      container !== this.body\n    ) {\n      // @ts-expect-error\n      container = container?.parentNode ?? null;\n    }\n\n    return container;\n  }\n\n  /**\n   * Function that returns element rectangle & position (width, height, top, left)\n   * @function\n   * @param {node} element - Element which position & rectangle are returned\n   * @return {object}\n   */\n  getRectangle(element: StickyElement) {\n    this.css(element, { position: \"\", width: \"\", top: \"\", left: \"\" });\n\n    const width = Math.max(\n      element.offsetWidth,\n      element.clientWidth,\n      element.scrollWidth\n    );\n    const height = Math.max(\n      element.offsetHeight,\n      element.clientHeight,\n      element.scrollHeight\n    );\n\n    let top = 0;\n    let left = 0;\n\n    do {\n      top += element.offsetTop || 0;\n      left += element.offsetLeft || 0;\n      element = element.offsetParent as StickyElement;\n    } while (element);\n\n    return { top, left, width, height };\n  }\n\n  /**\n   * Function that returns viewport dimensions\n   * @function\n   * @return {object}\n   */\n  getViewportSize() {\n    if (typeof window !== \"undefined\") {\n      return {\n        width: Math.max(\n          document.documentElement.clientWidth,\n          window.innerWidth || 0\n        ),\n        height: Math.max(\n          document.documentElement.clientHeight,\n          window.innerHeight || 0\n        ),\n      };\n    }\n  }\n\n  /**\n   * Function that updates window scroll position\n   * @function\n   * @return {number}\n   */\n  updateScrollTopPosition() {\n    if (typeof window !== \"undefined\") {\n      this.scrollTop =\n        (window.pageYOffset || document.body.scrollTop) -\n          (document.body.clientTop || 0) || 0;\n    }\n  }\n\n  /**\n   * Helper function for loops\n   * @helper\n   * @param {array}\n   * @param {function} callback - Callback function (no need for explanation)\n   */\n  forEach(\n    array: string | any[] | NodeListOf<Element>,\n    callback: {\n      (element: any): void;\n      (element: StickyElement): void;\n      (element: StickyElement): void;\n      (arg0: any): void;\n    }\n  ) {\n    for (let i = 0, len = array.length; i < len; i++) {\n      callback(array[i]);\n    }\n  }\n\n  /**\n   * Helper function to add/remove css properties for specified element.\n   * @helper\n   * @param {node} element - DOM element\n   * @param {object} properties - CSS properties that will be added/removed from specified element\n   */\n  css(\n    element: HTMLElement | null,\n    properties: {\n      [x: string]: any;\n      position?: string;\n      width?: string;\n      top?: string;\n      left?: string;\n      display?: string;\n      height?: string;\n      hasOwnProperty?: any;\n    }\n  ) {\n    for (let property in properties) {\n      if (properties.hasOwnProperty(property) && element) {\n        // @ts-expect-error\n        element.style[property] = properties[property];\n      }\n    }\n  }\n}\n","module.exports = require(\"lodash/merge\");"],"sourceRoot":""}